My research theme centers around the design and manufacture of systems which contain massive numbers of components. My goal is to understand how to build robust and useful systems which can scale towards millions, billions or even Moles of components. While my main emphasis is on manufactured artifacts, I am also interested in how distributed systems of people can be effectively designed. In pursuit of this goal I am working in several different areas of computer science, electrical engineering, robotics, and public policy. My current main projects are The Claytronics Project (programmable Matter and Emergent Behavior) and Government 2.0. Past projects include the Phoenix project (www.cs.cmu.edu/~phoenix). The goal of the Claytronics project (www.cs.cmu.edu/~claytronics) is to develop a form of programmable matter which moves programmability from the domain of computing into the domain of everyday matter. The idea is to create an ensemble of millions of very simple particles (the size of a grain of sand), each of which can compute, communicate, move, and adhere to one another. When taken as a whole, the ensemble can run a program which will result in the ensemble forming arbitrary dynamic shapes which can exert forces in the real world. In pursuit of this goal we are experimenting with building robots, developing programming languages, designing new debugging tools, creating new distributed algorithms, and studying emergence. Meld, a programming language for massively distributed and concurrent systems, is one of the out growths of the Claytronics project. We are currently looking at how to use Meld to program both ensembles and more traditional parallel systems including multi-core processors and the cloud. In addition to building sub-mm robots for the Claytronics project we are also pursuing more near-term goals of creating ensembles of smart interacting Lego-like blocks on the scale of tens to hundreds of units. These blocks, known as BlinkyBlocks, have been used by students around the world to play with the ideas behind programmable matter and develop a new understanding of how to program massively distributed systems. Government 2.0 is looking at how to harness prevalent web tools with model checking and simulation to construct a system which crowd sources governence at a local, state, and country wide level.
