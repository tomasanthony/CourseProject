 Ruzica Piskac Publications Projects Professional Activities Teaching Group Ruzica Piskac is an assistant professor (tenure-track) at Yale , Computer Science Department . Her research interests span the areas of programming languages, software verification, automated reasoning, and code synthesis. A common thread in Ruzica's research is improving software reliability and trustworthiness using formal techniques. Ruzica has received a NSF CAREER award for her proposal, "Synthesis in a Live Programming Environment". Ruzica received her PhD degree from the cole polytechnique fdrale de Lausanne ( EPFL ) in 2011. She was awarded the Patrick Denantes Memorial Prize for her PhD dissertation. Her advisor was Viktor Kunak . She holds a Master's degree in Computer Science, obtained from the University of Saarland (supervised by Harald Ganzinger at Max-Planck Institute for Computer Science ) in Saarbrcken, Germany, as well as a Master's degree in mathematics from the University of Zagreb , Croatia. For more information, see her complete CV . Address Yale University 51 Prospect Street, office AKW 212 New Haven, CT 06511 Telephone (203) 432 8001 E-Mail Publications: Recent All Probabilistic Automated Language Learning for Configuration Files Mark Santolucito, Ennan Zhai, and Ruzica Piskac In Proceedings of Computer Aided Verification (CAV), 2016 A Type-Directed Approach to Program Repair Alex Reinking and Ruzica Piskac In Proceedings of Computer Aided Verification (CAV), 2015 StriSynth: Synthesis for Live Programming Sumit Gulwani, Mikal Mayer, Filip Niksic, and Ruzica Piskac In Proceedings of International Conference on Software Engineering (ICSE), 2015 InSynth: A System for Code Completion using Types and Weights Tihomir Gvero, Viktor Kuncak, Ivan Kuraj, and Ruzica Piskac In Proceedings of Software Engineering & Management, 2015 From Decision Procedures to Synthesis Procedures Ruzica Piskac In Proceedings of Symposium on Symbolic and Numeric Algorithms for Scientific Computing, 2015 Probabilistic Automated Language Learning for Configuration Files Mark Santolucito, Ennan Zhai, and Ruzica Piskac In Proceedings of Computer Aided Verification (CAV), 2016 Paper (pdf) Software failures resulting from configuration errors have become commonplace as modern software systems grow increasingly large and more complex. The lack of language constructs in configuration files, such as types and grammars, has directed the focus of a configuration file verification towards building post-failure error diagnosis tools. In addition, the existing tools are generally language specific, requiring the user to define at least a grammar for the language models and explicit rules to check. In this paper, we propose a framework which analyzes datasets of correct configuration files and derives rules for building a language model from the given dataset. The resulting language model can be used to verify new configuration files and detect errors in them. Our proposed framework is highly modular, does not rely on the system source code, and can be applied to any new configuration file type with minimal user input. Our tool, named ConfigC, relies on an abstract representation of language rules to allow for this modularity. ConfigC supports learning of various rules, such as orderings, value relations, type errors, or user defined rules by using a probabilistic type inference strategy and defining a small interface for the rule type. Close A Type-Directed Approach to Program Repair Alex Reinking and Ruzica Piskac In Proceedings of Computer Aided Verification (CAV), 2015 Paper (pdf) Developing enterprise software often requires composing several libraries together with a large body of in-house code. Large APIs introduce a steep learning curve for new developers as a result of their complex object-oriented underpinnings. While the written code in general reflects a programmers intent, due to evolutions in an API, code can often become ill-typed, yet still syntactically-correct. Such code fragments will no longer compile, and will need to be updated. We describe an algorithm that automatically repairs such errors, and discuss its application to common problems in software engineering. Close StriSynth: Synthesis for Live Programming Sumit Gulwani, Mikal Mayer, Filip Niksic, and Ruzica Piskac In Proceedings of International Conference on Software Engineering (ICSE), 2015 Paper (pdf) Motivated by applications in automating repetitive file manipulations, we present a tool called StriSynth, which allows end-users to perform transformations over data using examples. Based on provided examples, our tool automatically generates scripts for non-trivial file manipulations. Although the current focus of StriSynth are file manipulations, it implements a more general string transformation framework. This framework builds on and further extends the functionality of Flash Fill -- a Microsoft Excel extension for string transformations. Close InSynth: A System for Code Completion using Types and Weights Tihomir Gvero, Viktor Kuncak, Ivan Kuraj, and Ruzica Piskac In Proceedings of Software Engineering & Management, 2015 Paper (pdf) Developing modern software typically involves composing functionality from existing libraries. This task is difficult because libraries may expose many methods to the developer. To help developers in such scenarios, we present a technique that synthesizes and suggests valid expressions of a given type at a given program point. As the basis of our technique we use type inhabitation for lambda calculus terms in long normal form. We introduce a succinct representation for type judgements that merges types into equivalence classes to reduce the search space, then reconstructs any desired number of solutions on demand. Furthermore, we introduce a method to rank solutions based on weights derived from a corpus of code. We implemented the algorithm and deployed it as a plugin for the Eclipse IDE for Scala. We show that the techniques we incorporated greatly increase the effectiveness of the approach. Our evaluation benchmarks are code examples from programming practice; we make them available for future comparisons. The results presented here were published as a research paper at the ACM SIGPLAN Conference on Programming Language Design and Implementation, (PLDI 13), Seattle, WA, USA, June 16-19, 2013. This extended abstact also contains some excerpts from the original paper. Close From Decision Procedures to Synthesis Procedures Ruzica Piskac In Proceedings of Symposium on Symbolic and Numeric Algorithms for Scientific Computing, 2015 Paper (pdf) Software synthesis is a technique for automatically generating code from a given specification. The goal of software synthesis is to make software development easier while increasing both the productivity of the programmer and the correctness of the produced code. In this paper we present an approach to synthesis that relies on the use of automated reasoning and decision procedures. First we describe how to generalize decision procedures into predictable and complete synthesis procedures. Here completeness means that the procedure is guaranteed to find code that satisfies the given specification. We illustrate the process of turning a decision procedure into a synthesis procedure using linear integer arithmetic as an example. However, writing a complete specification can be a tedious task, sometimes even harder than writing the code itself. To overcome this problem, ideally the user could provide a few input-output examples, and then the code should be automatically derived. We outline how to broaden usability and applications of current software synthesis techniques. We conclude with an outlook on possible future research directions and applications of synthesis procedures. Close Conference Papers Probabilistic Automated Language Learning for Configuration Files Mark Santolucito, Ennan Zhai, and Ruzica Piskac In Proceedings of Computer Aided Verification (CAV), 2016 A Type-Directed Approach to Program Repair Alex Reinking and Ruzica Piskac In Proceedings of Computer Aided Verification (CAV), 2015 StriSynth: Synthesis for Live Programming Sumit Gulwani, Mikal Mayer, Filip Niksic, and Ruzica Piskac In Proceedings of International Conference on Software Engineering (ICSE), 2015 InSynth: A System for Code Completion using Types and Weights Tihomir Gvero, Viktor Kuncak, Ivan Kuraj, and Ruzica Piskac In Proceedings of Software Engineering & Management, 2015 From Decision Procedures to Synthesis Procedures Ruzica Piskac In Proceedings of Symposium on Symbolic and Numeric Algorithms for Scientific Computing, 2015 Probabilistic Automated Language Learning for Configuration Files Mark Santolucito, Ennan Zhai, and Ruzica Piskac In Proceedings of Computer Aided Verification (CAV), 2016 Paper (pdf) Software failures resulting from configuration errors have become commonplace as modern software systems grow increasingly large and more complex. The lack of language constructs in configuration files, such as types and grammars, has directed the focus of a configuration file verification towards building post-failure error diagnosis tools. In addition, the existing tools are generally language specific, requiring the user to define at least a grammar for the language models and explicit rules to check. In this paper, we propose a framework which analyzes datasets of correct configuration files and derives rules for building a language model from the given dataset. The resulting language model can be used to verify new configuration files and detect errors in them. Our proposed framework is highly modular, does not rely on the system source code, and can be applied to any new configuration file type with minimal user input. Our tool, named ConfigC, relies on an abstract representation of language rules to allow for this modularity. ConfigC supports learning of various rules, such as orderings, value relations, type errors, or user defined rules by using a probabilistic type inference strategy and defining a small interface for the rule type. Close A Type-Directed Approach to Program Repair Alex Reinking and Ruzica Piskac In Proceedings of Computer Aided Verification (CAV), 2015 Paper (pdf) Developing enterprise software often requires composing several libraries together with a large body of in-house code. Large APIs introduce a steep learning curve for new developers as a result of their complex object-oriented underpinnings. While the written code in general reflects a programmers intent, due to evolutions in an API, code can often become ill-typed, yet still syntactically-correct. Such code fragments will no longer compile, and will need to be updated. We describe an algorithm that automatically repairs such errors, and discuss its application to common problems in software engineering. Close StriSynth: Synthesis for Live Programming Sumit Gulwani, Mikal Mayer, Filip Niksic, and Ruzica Piskac In Proceedings of International Conference on Software Engineering (ICSE), 2015 Paper (pdf) Motivated by applications in automating repetitive file manipulations, we present a tool called StriSynth, which allows end-users to perform transformations over data using examples. Based on provided examples, our tool automatically generates scripts for non-trivial file manipulations. Although the current focus of StriSynth are file manipulations, it implements a more general string transformation framework. This framework builds on and further extends the functionality of Flash Fill -- a Microsoft Excel extension for string transformations. Close InSynth: A System for Code Completion using Types and Weights Tihomir Gvero, Viktor Kuncak, Ivan Kuraj, and Ruzica Piskac In Proceedings of Software Engineering & Management, 2015 Paper (pdf) Developing modern software typically involves composing functionality from existing libraries. This task is difficult because libraries may expose many methods to the developer. To help developers in such scenarios, we present a technique that synthesizes and suggests valid expressions of a given type at a given program point. As the basis of our technique we use type inhabitation for lambda calculus terms in long normal form. We introduce a succinct representation for type judgements that merges types into equivalence classes to reduce the search space, then reconstructs any desired number of solutions on demand. Furthermore, we introduce a method to rank solutions based on weights derived from a corpus of code. We implemented the algorithm and deployed it as a plugin for the Eclipse IDE for Scala. We show that the techniques we incorporated greatly increase the effectiveness of the approach. Our evaluation benchmarks are code examples from programming practice; we make them available for future comparisons. The results presented here were published as a research paper at the ACM SIGPLAN Conference on Programming Language Design and Implementation, (PLDI 13), Seattle, WA, USA, June 16-19, 2013. This extended abstact also contains some excerpts from the original paper. Close From Decision Procedures to Synthesis Procedures Ruzica Piskac In Proceedings of Symposium on Symbolic and Numeric Algorithms for Scientific Computing, 2015 Paper (pdf) Software synthesis is a technique for automatically generating code from a given specification. The goal of software synthesis is to make software development easier while increasing both the productivity of the programmer and the correctness of the produced code. In this paper we present an approach to synthesis that relies on the use of automated reasoning and decision procedures. First we describe how to generalize decision procedures into predictable and complete synthesis procedures. Here completeness means that the procedure is guaranteed to find code that satisfies the given specification. We illustrate the process of turning a decision procedure into a synthesis procedure using linear integer arithmetic as an example. However, writing a complete specification can be a tedious task, sometimes even harder than writing the code itself. To overcome this problem, ideally the user could provide a few input-output examples, and then the code should be automatically derived. We outline how to broaden usability and applications of current software synthesis techniques. We conclude with an outlook on possible future research directions and applications of synthesis procedures. Close Journal Paper Thesis Workshop Papers Technical Reports Projects ConfigC Misconfiguration errors account for the majority of downtime in real-world deployed systems. ConfigC is a machine learning based system to automatically learn specifications for configuration files and check for correctness. It uses an association rule learning approach to build sets of predicates any correct configuration files must satisfy. G2 G2 is a symbolic execution framework for Haskell that utilizes evaluation and translation of semi-compiled Haskell source. The project is intended for automatic program exploration and input-output example generation, with additional goals to tackle difficult problems such as constraint solving for higher-order functions. Winston Winston is a type-directed expression synthesis tool that can also generate repairs of ill-typed expressions from their sound subexpressions. It uses a novel search space pruning technique based on graph distance to run interactively. GRASShopper GRASShopper is an experimental verification tool for programs that manipulate dynamically allocated data structures. GRASShopper programs can be annotated with specifications expressed in a decidable specification logic to check functional correctness properties. The logic supports mixing of separation logic and first-order logic assertions, yielding expressive yet concise specifications. Professional Activities: Program Committee Organizer FMCAD 2016 , 17th International Conference on Formal Methods in Computer-Aided Design. SMT 2016 , 14th International Workshop on Satisfiability Modulo Theories. GANDALF 2016 , 7th International Symposium on Games, Automata, Logics and Formal Verification. SYNT 2016 , 5th Workshop on Synthesis. AGERE 2015 , ACM SIGPLAN Workshop on Programming based on Actors, Agents, and Decentralized Control 2015. Scala 2015 , Scala Symposium 2015. Scala 2014 , annual Scala Workshop. POPL 2017 , member of the External Research Committee IJCAR 2016 FoSSaCS 2016 FASE 2016 CADE 2015 TACAS 2015 VMCAI 2015 SOFSEM 2015 JAR, special issue on interpolation 2014 AGERE 2014 POPL 2014 CSL-LICS 2014 Acta Informatica (Volume 52) POPL 2013 ESEC/FSE 2013 TASE 2013 VSTTE 2012 FM 2012 CONCUR 2012 FoSSaCS 2011 Awards The Microsoft Research Award for the Software Engineering Innovation Foundation (SEIF) 2014 Elected Member of Elisabeth-Schiemann-Kolleg, Max Planck Society, 2014 The Patrick Denantes Prize 2012 winner, awarded annually to an outstanding Master, Doctoral or Post-doc project from the I&C School" (the school of computer and communication sciences at EPFL) Research Highlight paper published in Communications of the ACM (55), Volume 55, Number 2, February 2012 Rising Stars in EECS: An Academic Career Workshop for Women, MIT, Cambridge, MA, 2012 - by invitation only The Google Anita Borg Memorial Scholarship 2010 winner Group Current members Ennan Zhai (Post-doctoral researcher) Mark Santolucito (PhD student) Bill Hallahan (PhD student) Anton Xue (Undergraduate student) Former members Alex Reinking (PhD student, UC Berkeley) ` 
